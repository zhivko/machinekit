/* Autogenerated by /usr/bin/comp -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:mythc:Torch Height Control");
MODULE_INFO(linuxcnc, "descr:\nTorch Height Control\nMesa THC > encoder > Machinekit THC component\n\nThe Mesa THC sends a frequency based on the voltage detected to the encoder.\nThe velocity from the encoder is converted to volts with the velocity scale\nparameter inside the THC component.\n\nThe THCAD card sends a frequency at 0 volts so the scale offset parameter is\nused to zero the calculated voltage.\n\nComponent Functions\nIf enabled and torch is on and X + Y velocity is within tolerance of set speed\nallow the THC to offset the Z axis as needed to maintain voltage.\n\nIf enabled and torch is off and the Z axis is moving up remove any correction\nat a rate not to exceed the rate of movement of the Z axis.\n\nIf enabled and torch is off and there is no correction\npass the Z position and feed back untouched.\n\nIf not enabled pass the Z position and feed back untouched.\n\nPhysical Connections\n\nPlasma Torch Arc Voltage Signal => 6 x 487k 1% resistors => THC Arc Voltage In\n\nTHC Frequency Signal => Encoder #0, pin A (Input)\n\nPlasma Torch Arc OK Signal => input pin\n\noutput pin => Plasma Torch Start Arc Contacts\n\nHAL Plasma Connections\n\nencoder.nn.velocity => thc.encoder-vel (tip voltage)\n\nmotion.spindle-on => output pin (start the arc)\n\nthc.arc-ok <= motion.digital-in-00 <= input pin (arc ok signal)\n\nHAL Motion Connections\n\nthc.requested-vel <= motion.requested-vel\n\nthc.current-vel <= motion.current-vel\n\n");
MODULE_INFO(linuxcnc, "author:John Thornton");
MODULE_INFO(linuxcnc, "license:GPLv2 or greater");
MODULE_INFO(linuxcnc, "pin:encoder_vel:float:0:in:Connect to hm2_5i20.0.encoder.00.velocity:None:None");
MODULE_INFO(linuxcnc, "pin:current_vel:float:0:in:Connect to motion.current-vel:None:None");
MODULE_INFO(linuxcnc, "pin:requested_vel:float:0:in:Connect to motion.requested-vel:None:None");
MODULE_INFO(linuxcnc, "pin:volts_requested:float:0:in:Tip Volts current_vel >= min_velocity requested:None:None");
MODULE_INFO(linuxcnc, "pin:vel_tol:float:0:in:Velocity Tolerance (Corner Lock):None:None");
MODULE_INFO(linuxcnc, "pin:torch_on:bit:0:in:Connect to motion.spindle-on:None:None");
MODULE_INFO(linuxcnc, "pin:arc_ok:bit:0:in:Arc OK from Plasma Torch:None:None");
MODULE_INFO(linuxcnc, "pin:enable:bit:0:in:Enable the THC, if not enabled Z position is passed through:None:None");
MODULE_INFO(linuxcnc, "pin:z_pos_in:float:0:in:Z Motor Position Command in from axis.n.motor-pos-cmd:None:None");
MODULE_INFO(linuxcnc, "pin:z_pos_out:float:0:out:Z Motor Position Command Out:None:None");
MODULE_INFO(linuxcnc, "pin:z_fb_out:float:0:out:Z Position Feedback to Axis:None:None");
MODULE_INFO(linuxcnc, "pin:volts:float:0:out:The Calculated Volts:None:None");
MODULE_INFO(linuxcnc, "pin:vel_status:bit:0:out:When the THC thinks we are at requested speed:None:None");
MODULE_INFO(linuxcnc, "pin:offset_value:float:0:out:The Current Offset:None:None");
MODULE_INFO(linuxcnc, "pin:vel_scale:float:0:in:The scale to convert the Velocity signal to Volts:None:None");
MODULE_INFO(linuxcnc, "pin:scale_offset:float:0:in:The offset of the velocity input at 0 volts:None:None");
MODULE_INFO(linuxcnc, "pin:velocity_tol:float:0:in:The deviation percent from planned velocity:None:None");
MODULE_INFO(linuxcnc, "pin:voltage_tol:float:0:in:The deviation of Tip Voltage before correction takes place:None:None");
MODULE_INFO(linuxcnc, "pin:correction_vel:float:0:in:The amount of change in user units per period to move Z to correct:None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPLv2 or greater");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *encoder_vel;
    hal_float_t *current_vel;
    hal_float_t *requested_vel;
    hal_float_t *volts_requested;
    hal_float_t *vel_tol;
    hal_bit_t *torch_on;
    hal_bit_t *arc_ok;
    hal_bit_t *enable;
    hal_float_t *z_pos_in;
    hal_float_t *z_pos_out;
    hal_float_t *z_fb_out;
    hal_float_t *volts;
    hal_bit_t *vel_status;
    hal_float_t *offset_value;
    hal_float_t *vel_scale;
    hal_float_t *scale_offset;
    hal_float_t *velocity_tol;
    hal_float_t *voltage_tol;
    hal_float_t *correction_vel;
    float offset;

    float last_z_in;

    float z_pos_out1;

};
struct __comp_state *__comp_inst=0;
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_IN, &(inst->encoder_vel), comp_id,
        "%s.encoder-vel", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->current_vel), comp_id,
        "%s.current-vel", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->requested_vel), comp_id,
        "%s.requested-vel", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->volts_requested), comp_id,
        "%s.volts-requested", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->vel_tol), comp_id,
        "%s.vel-tol", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->torch_on), comp_id,
        "%s.torch-on", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->arc_ok), comp_id,
        "%s.arc-ok", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable), comp_id,
        "%s.enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->z_pos_in), comp_id,
        "%s.z-pos-in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->z_pos_out), comp_id,
        "%s.z-pos-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->z_fb_out), comp_id,
        "%s.z-fb-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->volts), comp_id,
        "%s.volts", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->vel_status), comp_id,
        "%s.vel-status", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->offset_value), comp_id,
        "%s.offset-value", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->vel_scale), comp_id,
        "%s.vel-scale", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->scale_offset), comp_id,
        "%s.scale-offset", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->velocity_tol), comp_id,
        "%s.velocity-tol", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->voltage_tol), comp_id,
        "%s.voltage-tol", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->correction_vel), comp_id,
        "%s.correction-vel", prefix);
    if(r != 0) return r;
    inst->offset = 0.0;
    inst->last_z_in = 0.0;
    inst->z_pos_out1 = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    if(!__comp_inst) __comp_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("mythc");
    if(comp_id < 0) return comp_id;
    r = export("mythc", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef encoder_vel
#define encoder_vel (0+*__comp_inst->encoder_vel)
#undef current_vel
#define current_vel (0+*__comp_inst->current_vel)
#undef requested_vel
#define requested_vel (0+*__comp_inst->requested_vel)
#undef volts_requested
#define volts_requested (0+*__comp_inst->volts_requested)
#undef vel_tol
#define vel_tol (0+*__comp_inst->vel_tol)
#undef torch_on
#define torch_on (0+*__comp_inst->torch_on)
#undef arc_ok
#define arc_ok (0+*__comp_inst->arc_ok)
#undef enable
#define enable (0+*__comp_inst->enable)
#undef z_pos_in
#define z_pos_in (0+*__comp_inst->z_pos_in)
#undef z_pos_out
#define z_pos_out (*__comp_inst->z_pos_out)
#undef z_fb_out
#define z_fb_out (*__comp_inst->z_fb_out)
#undef volts
#define volts (*__comp_inst->volts)
#undef vel_status
#define vel_status (*__comp_inst->vel_status)
#undef offset_value
#define offset_value (*__comp_inst->offset_value)
#undef vel_scale
#define vel_scale (0+*__comp_inst->vel_scale)
#undef scale_offset
#define scale_offset (0+*__comp_inst->scale_offset)
#undef velocity_tol
#define velocity_tol (0+*__comp_inst->velocity_tol)
#undef voltage_tol
#define voltage_tol (0+*__comp_inst->voltage_tol)
#undef correction_vel
#define correction_vel (0+*__comp_inst->correction_vel)
#undef offset
#define offset (__comp_inst->offset)
#undef last_z_in
#define last_z_in (__comp_inst->last_z_in)
#undef z_pos_out1
#define z_pos_out1 (__comp_inst->z_pos_out1)


#line 101 "mythc.comp"

#include "rtapi_math.h"

FUNCTION(_) {
    // convert encoder velocity to volts
    volts = round((encoder_vel - scale_offset) * vel_scale * 10.0)/10.0;
    if(volts < 0){volts = 0;} // make sure volts is not negative
    offset_value = offset;

    if(enable){
        float min_velocity = requested_vel -(requested_vel*(velocity_tol*0.01));
        if(current_vel > 0 && current_vel >= min_velocity){vel_status = 1;}
        else {vel_status =0;}
        
        if(torch_on && arc_ok && vel_status){ // allow correction
            if((volts + voltage_tol) > volts_requested && (offset>-5 && offset<5)){
                offset -= correction_vel;
            }
            if((volts - voltage_tol) < volts_requested && (offset>-5 && offset<5)){
                offset += correction_vel;
            }    
            last_z_in = 0;
        }
        if(!torch_on){ // remove any offset
            float z_diff;
            z_diff = z_pos_in - last_z_in;
            if(z_diff > 0 && offset != 0){ // torch is moving up
                if(offset > 0){ // positive offset
                    if(offset > z_diff){ // remove some
                        offset -= z_diff;
                    }
                    else {offset = 0;}
                }
                if(offset < 0){ // negative offset
                    if(offset < z_diff){ // remove some
                        offset += z_diff;
                    }
                    else {offset = 0;}
                }
            }
            last_z_in = z_pos_in;
        }
		z_pos_out = round((z_pos_in + offset)*10.0)/10.0;
		z_fb_out = z_pos_in; // keep axis motor position fb from being confused
    }
    if(!enable){
        z_pos_out = z_pos_in;
        z_fb_out = z_pos_in; // keep axis motor position fb from being confused
    }
}


static int __comp_get_data_size(void) { return 0; }
