
/* Autogenerated by /home/machinekit/git/machinekit/bin/instcomp on Fri Oct 21 20:13:21 2016 -- do not edit */

#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "hal_priv.h"

static int comp_id;

static char *compname = "udp";


#ifdef MODULE_INFO
MODULE_INFO(machinekit, "component:udp:Connects to laser esp8266 of laser distance sensor (ODSL 9/D26-450-S12 - Optical distance sensor)");
MODULE_INFO(machinekit, "pin:distance:float:None:out::None");
MODULE_INFO(machinekit, "funct:_:1:");
MODULE_INFO(machinekit, "author:test");
MODULE_INFO(machinekit, "license:GPL");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO
RTAPI_TAG(HAL,HC_INSTANTIABLE);


struct inst_data {

    hal_float_t *distance;
    int localpincount;
};

static int maxpins __attribute__((unused)) = 0;
static char *iprefix = "";
static int _(void *arg, const hal_funct_args_t *fa);

static int instantiate(const int argc, const char**argv);

static int extra_inst_setup(struct inst_data* ip, const char *name, int argc, const char**argv);

#undef TRUE
#undef FALSE
#undef true
#define true (1)
#undef false
#define false (0)

static int export_halobjs(struct inst_data *ip, int owner_id, const char *name)
{
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j __attribute__((unused)) = 0;
    int z __attribute__((unused)) = 0;
    r = hal_pin_float_newf(HAL_OUT, &(ip->distance), owner_id,
            "%s.distance", name);
    if(r != 0) return r;

    // export an extended thread function:
    hal_export_xfunct_args_t __xf = { 
        .type = FS_XTHREADFUNC,
        .funct.x = _,
        .arg = ip,
        .uses_fp = 1,
        .reentrant = 0,
        .owner_id = owner_id
    };

    rtapi_snprintf(buf, sizeof(buf),"%s", name);
    r = hal_export_xfunctf(&__xf, buf, name);
    if(r != 0)
        return r;
    return 0;
}

// constructor - init all HAL pins, params, funct etc here
static int instantiate(const int argc, const char**argv)
{
    const char *name  __attribute__((unused)) = argv[1];
    struct inst_data *ip;
    int r;
    int k;

    // allocate a named instance, and some HAL memory for the instance data
    int inst_id = hal_inst_create(name, comp_id, sizeof(struct inst_data), (void **)&ip);

    if (inst_id < 0)
        return -1;

    // here ip is guaranteed to point to a blob of HAL memory of size sizeof(struct inst_data).
    hal_print_msg(RTAPI_MSG_DBG,"%s inst=%s argc=%d",__FUNCTION__, name, argc);

    // Debug print of params and values

    // These pins - params - functs will be owned by the instance
    // which can be separately exited with delinst
    if(strlen(iprefix))
        r = export_halobjs(ip, inst_id, iprefix);
    else
        r = export_halobjs(ip, inst_id, name);
    // if the extra_inst_setup returns non zero will abort module creation
    k = extra_inst_setup(ip, name, argc, argv);

    if(k != 0)
        return k;

    return r;
}

int rtapi_app_main(void)
{
    // Debug print of params and values
    comp_id = hal_xinit(TYPE_RT, 0, 0, instantiate, NULL, compname);
    if (comp_id < 0)
        return -1;

    hal_ready(comp_id);

    return 0;
}

void rtapi_app_exit(void)
{
    hal_exit(comp_id);
}


#undef FUNCTION
#define FUNCTION(name) static int name(void *arg, const hal_funct_args_t *fa)
// if the extra_inst_setup returns non zero it will abort the module creation
#undef EXTRA_INST_SETUP
#define EXTRA_INST_SETUP() static int extra_inst_setup(struct inst_data *ip, const char *name, int argc, const char**argv)
#undef fperiod
#define fperiod (period * 1e-9)
#undef distance
#define distance (*ip->distance)
#undef localpincount
#define localpincount (ip->localpincount)


#line 16 "./components/udp.icomp"

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ifaddrs.h>
#include <pthread.h>
#include <string.h>

#define BUFSIZE 1024
#define SERVER_PORT 1234
#define MAX_THREADS 4

int myPort;
const char* myIp;
float recValue;

float distance = 5.5;
int shouldRun = 1;
pthread_t pth;	// this is our thread identifier

struct sockaddr_in server;

/*
int main() {
	printf("start...\n");
	char **argv = (char *[]){"ip=192.168.1.155", "port=1234"};

	EXTRA_INST_SETUP(NULL, "MyTest", 1, argv);
	printf("end.\ns");
}
*/

/* This is our thread function.  It is like mapin(), but for a thread */
void *threadFunc(void *arg) {

	int sockfd; /* socket */
	int portno; /* port to listen on */
	int clientlen; /* byte size of client's address */
	struct sockaddr_in serveraddr; /* server's addr */
	struct sockaddr_in clientaddr; /* client addr */
	struct hostent *hostp; /* client host info */
	char buf[BUFSIZE]; /* message buf */
	char *hostaddrp; /* dotted decimal host addr string */
	int optval; /* flag value for setsockopt */
	int n; /* message byte size */

	printf("\tThread starting...\n");
	/*
	 * socket: create the parent socket
	 */
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	printf("\tsocket no: %d\n",sockfd);

	if (sockfd < 0)
		printf("ERROR opening socket");

	/* setsockopt: Handy debugging trick that lets
	 * us rerun the server immediately after we kill it;
	 * otherwise we have to wait about 20 secs.
	 * Eliminates "ERROR on binding: Address already in use" error.
	 */
	optval = 1;
	setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *) &optval, sizeof(int));

	/*
	 * build the server's Internet address
	 */
	bzero((char *) &serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVER_PORT);

	/*
	 * bind: associate the parent socket with a port
	 */
	if (bind(sockfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
		printf("ERROR on binding");

	/*
	 * main loop: wait for a datagram, then echo it
	 */
	clientlen = sizeof(clientaddr);
	while (shouldRun) {

		/*
		 * recvfrom: receive a UDP datagram from a client
		 */
		bzero(buf, BUFSIZE);
		n = recvfrom(sockfd, buf, BUFSIZE, 0, (struct sockaddr *) &clientaddr, &clientlen);
		if (n < 0)
			error("ERROR in recvfrom");

		/*
		 * gethostbyaddr: determine who sent the datagram
		 */
		hostp = gethostbyaddr((const char *) &clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET);
		if (hostp == NULL)
			error("ERROR on gethostbyaddr");
		hostaddrp = inet_ntoa(clientaddr.sin_addr);
		if (hostaddrp == NULL)
			error("ERROR on inet_ntoa\n");
		printf("server received datagram from %s (%s)\n", hostp->h_name, hostaddrp);
		printf("server received %d/%d bytes: %s\n", strlen(buf), n, buf);

		/*
		 * sendto: echo the input back to the client
		 */
		n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *) &clientaddr, clientlen);
		if (n < 0)
			error("ERROR in sendto");
	}
	pthread_exit(NULL);
}

char** str_split(char* a_str, const char a_delim) {
	char** result = 0;
	size_t count = 0;
	char* tmp = a_str;
	char* last_comma = 0;
	char delim[2];
	delim[0] = a_delim;
	delim[1] = 0;

	/* Count how many elements will be extracted. */
	while (*tmp) {
		if (a_delim == *tmp) {
			count++;
			last_comma = tmp;
		}
		tmp++;
	}

	/* Add space for trailing token. */
	count += last_comma < (a_str + strlen(a_str) - 1);

	/* Add space for terminating null string so caller
	 knows where the list of returned strings ends. */
	count++;

	result = malloc(sizeof(char*) * count);

	if (result) {
		size_t idx = 0;
		char* token = strtok(a_str, delim);

		while (token) {
			*(result + idx++) = strdup(token);
			token = strtok(0, delim);
		}
		*(result + idx) = 0;
	}

	return result;
}

EXTRA_INST_SETUP() {
	printf("UDP Inst setup\n");
	int x;

	recValue = 5.5;
	char** tokens;
	char* parValue;
	pthread_attr_t attr;

	for (x = 0; x < argc; x++) {
		//hal_print_msg(RTAPI_MSG_ERR,"argv[%d] = %s", x, argv[x]);
		parValue = argv[x];
		char *dupParValue = strdup(parValue);
		tokens = str_split(dupParValue, "=");
		if (tokens[0] == "ip")
			myIp = (char*) (*(tokens + 1));
		if (tokens[0] == "port")
			myPort = atoi(*(tokens + 1));
	}

	void *status;

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	/* Create worker thread */
	pthread_create(&pth, &attr, threadFunc, "processing...");
	pthread_join(pth, &status);


	pthread_exit(NULL);

}

FUNCTION( _) {
    long period __attribute__((unused)) = fa_period(fa);
    struct inst_data *ip = arg;

	distance = recValue;
}



EXTRA_CLEANUP() {
    shouldRun = 0;
}

